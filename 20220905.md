# 오늘 공부한 내용
- [x] 딥다이브 복습하기
- [x] todolist ver.1 복습하기
- [x] 비동기 학습

# 딥다이브 복습 (4장. 변수)

**어플리케이션에서 변수를 다룬다.** 

애플리케이션은 데이터를 입력받아 처리하고 결과를 출력하는 일을 함 

**변수** : **프로그래밍 내에서 데이터를 관리하기 위한 핵심 개념,** 

**하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름** 

**10+20**

자바스크립트 엔진이 코드를 **계산**(**평가**)하려면 먼저, 10, 20, +이라는 **기호**(**리터럴**과 **연산자**)의 의미를 알고 있어야 하며, 10+20이라는 **식**(**표현식**)의 의미도 **해석**(**파싱**)할 수 있어야 한다. 

위 식의 의미를 해석하려면 연산자의 좌변과 우변의 숫자값 (피연산자들)을 기억해야한다. 

컴퓨터는 **CPU**를 통해 **연산**하고, **메모리**를 ****사용해 **데이터**를 **기억**한다. 

**메모리** : 데이터를 저장할 수 있는 메모리 셀의 집합체 
**메모리 셀** : 하나의 크기는 1바이트(8비트)이며, 컴퓨터의 메모리 셀의 크기 단위로 데이터를 저장하거나 읽는다.


**각 셀은 고유의 메모리 주소를 가짐**. 메모리 주소는 **메모리 공간의 위치**를 나타낸다. 0부터 시작해 메모리의 크기만큼 정수로 표현된다. 위 사진은 4GB 메모리이다.

**컴퓨터는 모든 데이터를 종류에 상관 없이 2진수로 처리**한다. 위 사진은 편의로 10, 20 이라고 넣은 것. 10과 20은 메모리 사으이 임의의 위치(메모리 주소)에 기억(저장)이 되고 CPU는 이값을 읽어서 연산을 수행함. 연산 결과인 30도 임의의 위치에 저장된다. 

메모리 공간에 저장된 값을 식별할 수 있는 이름 =  변수 이름(변수명)

변수에 저장된 값(30) = 변수 값

변수에 값을 저장한다 = 할당(대입, 저장)

변수에 저장된 값을 읽어온다 = 참조 

변수 이름을 사용해 참조를 요청하면 자바스크립트 엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환한다. 

# 식별자

**변수의 이름 = 식별자**

- ***어떤 값을 구별해서 식별할 수 있는 고유한 이름***
- 같은 메모리 공간에 저장되어 있다 ⇒ 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별할 수 있어야 함
- 이를 위해 식별자는 **어떤 값이 저장되어 있는 메모리 주소를 기억(저장)**해야 한다.
- EX ) 식별자 RESULT는 값 30을 식별할 수 있었다. 이를 위해 식별자 result는 값 30이 저장되어 있는 메모리 주소를 기억해야한다.
- 즉, **식별자**는 값이 저장되어 있는 **메모리 주소**와 **매핑 관계**를 맺으며 이 **매핑 정보**도 **메모리에 저장**되어야 한다.
- **식별자는** 값이 아니라 **메모리 주소를 기억**하고 있다. 식별자로 값을 구별해서 식별한다는 것은 식별자가 기억하고 있는 **메모리 주소를 통해 메모리 공간에 저장된 값에 접근**할 수 있다
- 즉, **식별자는 메모리 주소에 붙인 이름**이다.


🔥 식별자는 메모리 이름이고 여기에는 주소가 매핑되어 있어서 주소를 통해 값에 접근한다. 

- 변수, 함수, 클래스 등이 모두 식별자이다
- 식별자인 변수 이름으로는 **메모리 상에 존재하는 변수 값을 식별**할 수 있고, 함수 이름으로는 메모리 상에 존재하는 함수(자바스크립트에서 함수는 값이다)를 식별할 수 있다. ⇒ **메모리 상에 존재하는 어떤 값을 식별할 수 있는 모든 이름을 식별자**라고 부른다.

# 변수 선언

값을 저장하기 위한 **메모리 공간을 확보**하고 **변수 이름과** 확보된 **메모리 공간의 주소를 연결**해서 **값을 저장할 수 있게 준비**하는것

- 반드시 선언을 해야함 → let, const, var(var ⇒ 함수레벨스코프) 키워드 사용
- 

<aside>
💡 **키워드**
자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어.

자바스크립트 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행함

</aside>

# 변수 선언의 실행 시점과 변수 호이스팅

변수 선언은 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 **런타임이 아니라 그 이전 단계**에서 먼저 실행되기 때문

- 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내 먼저 실행

### 호이스팅

변수 선언문이 코드의 선두로 끌어 올려진 것 처럼 동작하는 자바스크립트 고유의 특징

- var, let, const, function, function*, class 키워드를 사용해서 선언하는 모든 식별자는 호이스팅됨

# 값의 할당

```jsx
var score = 80; 

1. var score
2. score =80

/*
1. 변수 선언과 2. 값의 할당으로 나뉘어져서 각각 실행된다 
*/
```

### var같은 경우

처음에는 undefined가 할당이 되고 새로운 메모리 공간에 값이 할당됨


# 값의 재할당

이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것 

### 상수

- 값을 재할당 할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수
- 단 한번만 할당할 수 있는 변수

<aside>
💡 **가비지 콜렉터**

메모리 공간을 주기적으로 검사해서 더 이상 사용되지 않는 메모리를 해제하는 기능 
JS는 가비지 콜렉터를 내장하고 있는 매니지드 언어로 가비지 콜렉터를 통해 메모리 누수를 방지함

</aside>

<aside>
💡 **매니지드 언어** & **언매니지드 언어

매지니드 언어 
- JS
-**  메모리 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당
- 개발자의 직접적인 메모리 제어를 허용하지 않음 
- 개발자가 명시적으로 메모리를 할당하고 해제할 수 없음
**-** 개발자의 역량에 의존하는 부분이 상대적으로 작아져서 어느 정도 일정한 생산성을 확보할 수 있다는 장점 있음
- 성능 면에서 어느정도의 손실을 감수할 수 밖에 없음

언매니지드 언어
- 메모리 제어를 개발자가 주도할 수 있음
- 개발자 역량에 따라서 최적의 성능 확보

</aside>

# 식별자 네이밍 규칙

- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러기호($)를 포함할 수 있음
- 단, 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러기호($)로 시작해야 함. 숫자로 시작하는 것은 허용하지 않음
- 예약어는 식별자로 사용할 수 없다.


```jsx
// 카멜 케이스 (camelCase)
var firstName;

// 스네이크 케이스 (snake_case)
var first_name;

// 파스칼 케이스 (PascalCase)
var FirstName;

// 헝가리언 케이스 (typeHungarianCase)
var strFirstName; // type + identifier
var $elem = document.getElementById('myId'); // DOM 노드
var observable$ = fromEvent(document, 'click'); // RxJS 옵저버블
```


# 비동기 학습 (Ajax, fetch, async)
# Ajax

우선 Ajax는 **Asynchronous JavaScript And XML**의 약자입니다.

Ajax의 약자를 토대로 본래 의미를 살펴보면 JavaScript를 사용한 비동기 통신, **클라이언트와 서버간에 데이터를 주고받는 기술**이라고 할 수 있습니다.

HTML 과 여타 기술들을 사용하는 새로운 접근법이라고 설명하기도 하죠.

Ajax를 통해 서버와 비동기적으로 통신함으로 인해 우리는 전체 웹페이지를 다시 불러오는 동기 방식과는 다르게 점진적으로 해당 부분의 사용자 인터페이스를 갱신할 수 있습니다.

간단하게 말해서 Ajax는 **JavaScript에서 비동기 HTTP 통신이 가능하도록 해줍**니다. 

비동기 Http 통신이란 response와 request를 비동기 식으로 다룰 수 있다는 것을 의미합니다.

예를 들어 만약 페이스북에서 **좋아요 버튼을 누를 때마다 페이지가 갱신**이 된다면 음... 많이 불편했다.또는 구글에서 검색을 하는데 **추천 검색어가 로드될때마다 페이지가 새로고침**된다면 얼마나 짜증이 났었나.......

우리는 비동기식으로 데이터를 주고받으며 위의 문제들을 해결하는 것입니다.

순수 Ajax

```jsx
// use Ajax without Jquery

function reqListener (e) {
    console.log(e.currentTarget.response);
}

var oReq = new XMLHttpRequest();
var serverAddress = "https://jsonplaceholder.typicode.com/posts";

oReq.addEventListener("load", reqListener);
oReq.open("GET", serverAddress);
oReq.send();
```

# Axios

1. Promise 기반이 아님
2. jQuery를 통해 쉽게 구현가능하다

기존에 WEB에서 어떤 리소스를 비동기로 요청하기 위해서는 XHR(XML HTTP Request)객체를 사용했어야 했었는데, XHR은 잘 디자인되어 있는 API가 아닙니다. 

요청의 상태나 변경을 구독하려면 Event를 등록해서 변경사항을 받아야 했고 요청의 성공, 실패 여부나 상태에 따라 처리하는 로직이 들어가기 좋지 않았습니다.

이를 보완하기 위해 HTTP 요청에 최적화 되어 있고 상태도 잘 추상화 되어 있는 api들이 생겨나기 시작했습니다. 

대표적으로 Axios와 fetch가 그 예인데 중 Axios를 먼저 살펴보자

> **Axios**는 Promise based HTTP client for the browser and node.js
> 
> 
> 즉, node.js와 브라우저를 위한 HTTP통신 라이브러리입니다.
> 
> 비동기로 HTTP 통신을 가능하게 해주며 return을 promise 객체로 해주기 때문에 response 데이터를 다루기도 쉽습니다.
> 
> react를 사용하시는 분들은 후술할 fetch보다 Axios를 많이 선호하는 편이죠.
> 
> 

**Axios의 post method 구현**

```jsx
axios({
  method: 'post',
  url: '/user/12345',
  data: {
    firstName: 'Yongseong',
    lastName: 'Kim'
  }
});
```

****XMLHttpRequest(XHR)를 사용한 코드****

```jsx
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() { // 요청에 대한 콜백
  if (xhr.readyState === xhr.DONE) { // 요청이 완료되면
    if (xhr.status === 200 || xhr.status === 201) {
      console.log(xhr.responseText);
    } else {
      console.error(xhr.responseText);
    }
  }
};
xhr.open('GET', 'https://localhost:3000'); // 메소드와 주소 설정
xhr.send(); // 요청 전송 
// xhr.abort(); // 전송된 요청 취소
```

# fetch

fetch는 ES6부터 JavaScript의 내장 라이브러리로 들어왔습니다.

promise기반으로 만들어졌기에 Axios와 마찬가지로 데이터를 다루는데 어렵지 않으며, 내장 라이브러리라는 장점으로 인해 상당히 편리하죠. 코드 또한 간단합니다.

fecth의 post method

```jsx
//fetch
const url ='http://localhost3000/test`
const option ={
   method:'POST',
   header:{
     'Accept':'application/json',
     'Content-Type':'application/json';charset=UTP-8'
  },
  body:JSON.stringify({
  	name:'sewon',
    	age:20
  })

  fetch(url,options)
  	.then(response => console.log(response))
```

# **Axios vs fetch**

### Axios

### 장점

- response timeout 처리 방법이 있다. (fetch에는 존재하지 않는 기능)
- promise 기반으로 다루기가 쉽다
- **크로스 브라우징에 신경을 많이썼기에 브라우저 호환성이 뛰어나다.**

### 단점

- 모듈 설치를 해줘야한다.**(npm install axios)**

### fetch

### 장점

- 내장 라이브러리이기에 별도의 import를 해줄 필요가 없다.
- promise 기반으로 다루기가 쉽다.
- **내장 라이브러리이기에 사용하는 프레임워크가 안정적이지 않을 때 사용하기 좋다.**

### 단점

- internet explorer의 경우에는 fetch를 지원하지 않는 버전도 존재한다. (브라우저 호환성이 상대적으로 떨어진다.)
- 기능이 부족하다.
- JSON으로 변환해주는 과정이 필요함
- 네트워크 에러 발생 시 response timeout이 없어서 기다려야함
