# 오늘 한 일

- [x]  16장
- [x]  17장
- [x]  18장

# 오늘 배운 것 🌈

### 렉시컬 스코프

자바스크립트를 공부하면서 두번째로 중요한 개념이다. 

렉시컬 스코프의 주 목적은 식별자를 어디서 찾는지와 연관이 있다. 자바스크립트를 실행할 때 런타임 이전에 선언문을 찾아서 실행하는데 이때 자바스크립트 엔진에게 어떤 식별자가 있다는 것을 알려야한다. 이는 식별자가 겹치면안되기 때문이다. 

렉시컬 스코프는 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정된다. 대부분의 프로그래밍 언어가 렉시컬 스코프를 따른다. 자바스크립트는 렉시컬 스코프를 따르므로 함수를 선언한 시점에 상위 스코프가 결정된다. 

스코프는 단방향 링크드 리스트로 존재를 한다. 자기 자신 스코프에서 없으면 부모인 전역 스코프에 가서 찾는다. 전역 스코프는 자바스크립트가 실행될 때 런타임 이전에 선언문을 찾을 때 만들어진다. 만약 전역에도 찾는 값이 없으면 null이기 때문에 레퍼런스 오류가 난다. 

### 함수

<aside>
💡 bar()가 있으면 이 호출문에서 bar는 피 연산자이고 ()는 호출 연산자이다.

</aside>

위 내용을 함수에 대입해서 보면 함수는 런타임 이전에 선언문 파악시 정의된다. 이 과정에서 함수가 스코프를 만들고 이를 함수 레벨 스코프라고 한다. 함수 내부는 런타임에 호출문으로 인해 실행이된다. 똑같이 스코프가 있으면 자기 자신 스코프를 먼저 실행한다. 먼저 실행을 하고 전역 스코프를 참조하는데 여기서 렉시컬 스코프는 함수객체가 태어날 때 상위 스코프를 알고 태어난다. 상위 스코프는 `[[envrioment]]` 안에 있다. 이는 내부 슬롯이다. 즉, 다음 프로퍼티 (next) 키의 값을  `[[envrioment]]` 에서 가지고 온다. 

### 프로토타입 프로퍼티

프로퍼티의 값으로 모든 객체가 올 수 있다. 즉, 함수도 올 수 있음

프로퍼티의 값으로 함수가 오면 보통 메서드라고 부른다. (객체 안의 함수)

모든 객체는 `[[prototype]]`을 가진다.

함수 객체는 `[[envrioment]]`을 가진다. 

argument는 폐지가 됐다. 자바스크립트에서 폐지가 됐다는 것은 존재하지만 사용을 안한다는 뜻이다. 이는 하위 호환때문에 남겨둔다. 화살표 함수가 아닌 함수 내부에서 사용을 한다. 그렇다면 존재하는 이유는 무엇인가? 바로 인수를 받은 것들을 저장하려고 사용한다. 특히 매개변수를 선언하지 못하는 경우가 있는데 이를 가변 인자 함수라고 한다. 

프로퍼티에는 데이터 프로퍼티와 접근자 프로퍼티가 있다. 여기서 데이터 프로퍼티 중 `enumerable` 은 열거 가능한지의 여부이다. 열거가 가능하다는 것은 순서가 의미가 없다. 이는 유사 배열 객체와도 연관이 있다.

유사 배열 객체는 객체이면서 내가 원하는 메서드를 추가해서 배열로 순회할 수 있다는 점에서 사용한다. 대표적인 예로 document.queryselectorall은 유사배열 객체를 반환하기 때문에 `[…document.queryselectorall]` 로 담아서 반환해야 한다. 

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bd878dae-f07a-4ae8-9b05-59d01ee3de8a/Untitled.png)

### 생성자 함수

프로퍼티 구조가 동일한 객체를 생성할 때는 효율적이지 못하다. 따라서 생성자 함수를 사용해 인스턴스를 만들어낸다.  

```jsx
function Person(name){
  this.name = 'Lee',
};

//가독성이 안좋고, 캡슐화가 진행되지 않음 
Person.prototype.sayHi = function(){
    console.log('Hi! my name is ' + this.name);
  }

console.dir(person);
```

```jsx
const Person = (function () {
	function Person(name){
  this.name = 'Lee',
};

	Person.prototype.sayHi = function(){
	    console.log('Hi! my name is ' + this.name);
	}
	
return Person;
})();

//즉시 실행함수로 이런식으로 코드를 구성하면 인스턴스에 있던
// sayHi가 Person.prototype에 올라감

console.dir(person);
```

함수의 호출 방법에는 여러가지가 있다. 

1. 일반 함수 호출 방법
2. new 연산자를 사용한 생성자 함수로서 호출
3. 메서드로서 호출
    
    ```jsx
    const o = {Person : Person } 
    o.person()
    ```
    

### this

1. 일반 함수로 호출
2. 생성자 함수로 호출하는 인스턴스
3. 메서드로 호출하면 .앞에 있는 애
