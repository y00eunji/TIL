# 에러

1 * n에서 끝내는 게 아니라 원래 뭘 하려고 했으니 NaN, null이 아닌 에러를 발생시켜주는 것이 좋다. 

결국에는 다 재사용이다. 동일한 로직이 여기저기 흩어져있으면 안되고 한 곳에서만 일어나야 한다 → 에러를 묶어서 위에서 발생시켜야함 (최상위 : 전역) , 에러가 전파되어야한다. 

이 때 비동기는 에러를 전파받지 못해서 문제였음. 하지만 `**await`가 이걸 잡아줌. 따라서 await를 사용할 때 `try…catch` 를 사용안하면 감점**. `catch`에 `console.log()`라도 찍어라 

실행 컨텍스트에서 함수 호출자(caller) 는 바로 밑에 있는 실행컨텍스트임. 

비동기는 콜스택이 비면 넘어감 → 콜스택에 아무것도 없으면 호출자가 없음 → 호출자가 없으면 에러를 잡을 수 있음

## 에러를 던진다

`던진다 + 에러 객체를` 

에러 클래스를 하나 만들어서 상속받아서 만들어서 사용한다. 

에러를 발견해서 개발자가 해결해야하는게 1차적인 것이다. 

## try…catch…finally

finally는 자산을 해방시켜준다. (백엔드는 db를 하나 만들어서 연결을 해주거나 쿼리를 날리거나 db 연결을 끊는 경우를 finally에 넣는다. 프론트는 setTimeout을 실행했을 때 clear을 하고 나갈 때 사용하기도 함)

# 모듈

자바스크립트는 애플리케이션 개발을 위해 태어난 언어가 아니라 웹사이트의 보조적인 기능을 하기 위해 태어남. 따라서 ES5까지는 모듈이 지원이 안됨. 

모듈이 없으면 애플리케이션을 만들 수 없음. 모듈이 없는 상황에서 애플리케이션을 만들려면 한 파일로 만들어야 한다. 

모듈은 기능 기준으로 쪼개도되고 다양한 기준으로 쪼개도됨 (기능 또는 화면 별로 나누기)

폴더를 관리 잘해라!

## 자바스크립트에 모듈이 없었을 때

`<script>` 태그로 파일을 만들어야함 → 100개의 파일이 있을 때 태그를 100개 만들어야함.

- 파일을 아무리 쪼개도 전역을 공유한다
- 다른 파일의 전역 변수를 참조할 수 있어서 쪼개는 의미가 없다
- 변수를 재할당하고 함수도 같은 이름으로 만들면 함수를 덮는다
- 그래서 옛날에는 즉시 실행 함수를 사용해서 해결을 했다

## 모듈

동일한 식별자를 각각의 모듈에서는 스코프가 다르기 때문에 같은게 아니다.

모듈에서의 스코프는 `모듈 스코프`이다.

결론적으로는 모듈을 사용하면 **정보은닉**이 가능하다.  (class의 private이랑 비슷)

`export`: 다른 스코프에서도 얘를 보게 할 수 있게 해주겠다.

`import` : 사용하겠다.

### export 두가지방법

`defalut`, `named`

1. export `defalut` → import 식별자 from file이름.js (js는 웹팩사용시 사용안해도됨) (기본적으로 사용)
2. `named`

# babel

- 안쓰는 회사가 없음. 거의 준표준
- 현재 제안 중인 문법을 사용하고 싶은데 브라우저에서 지원을 해주지 않을 때 ES.NEXT (정식문법들만 → ES6+, 제안중인 문법들 )을 ES5 사양으로 소스코드를 트랜스파일링해줌
- polyfill : promise같은 없는 것들을 추가로 넣어줄 수 있게 ployfill을 사용할 수 있음

# Webpack

- 번들러
- 이전 버전들이 안먹히는 것들이 많음
- 1년에 1.5번 정도 업데이트한다
- Entry :  아무에게도 import안되는애가 모든 js파일의 진입점이므로 걔를 설정해달라
- Output : 어떤이름으로 어디다가 뱉어줄 건지 설정해라
- loaders : 어떤 툴을 사용해서 변환하지 설정해라(Sass같은 것들)
- modul.exports = {} → 설정파일을 export해주겠다

# CORS

브라우저에서 서버로 데이터를 요청해서 받아온 스크립트 를 가지고 다른 서버에 요청을 보내는 것은 해킹이 의심된다. 

처음에는 무조건 HTML을 받아오기 위해서 서버에 접근을 하는데 이때 이서버가 origin이고 다른 서버에 그 스크립트를 전송하면 해킹이 의심되는 것이다

HTTP ON을 사용해서 쿠키를 만들어서 자바스크립트가 못읽게 해야함.

HTTP요청은 요청을보냈던 서버(ORIGIN)로 다시 요청을 보내야한다.

브라우저가 CORS에러를 발생시킨다.

기능이 여러개이면 서버를 분산처리를 할 수 있는데 이때 CORS에 걸린다. 

결론적으로 서버에서 해결해줘야한다. 

# MVC

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/13172ab3-88a2-41d5-b002-729e43ae306c/Untitled.png)

M : 비지니스 로직 (todo 배열, todo 배열을 조작하는 애들)

C : 컨트롤러 

V : 화면 그리기 

⇒ MVC패턴을 일관된 패턴으로 만들어야하지만 꼭 MVC패턴으로 안불러도됨

⇒ 가장 핵심은 view가 contriller를 알아야한다

⇒ **화살표** = **함수를 호출하는 것 → 함수는 연결되는 부분의 api이다**  

최적화된 패턴을 만드는 것이 목적임 

state가 view를 업데이트 하는것임

통일된 로직이 없으면 가독성이 떨어짐 → 유지보수가 어려움 → 디버깅이 안됨

todos배열은 view에 영향을 주는 데이터 따라서 todos배열이 state

react에서 model의 state를 관리하는 것을 상태관리라고 함
