# 오늘 배운 것 🌈

## git
### revert vs reset

둘다 과거의 커밋을 건드리는 작업이다. 

`reset`:  시간을 과거의 특정 사건으로 되돌린다. 

`revert`: 현재에 있으면서 과거 특정 사건들만을 없던 일로 만드는 것 

### reset

특정 사건으로 되돌아가게 되는데 과거로 돌아갔으니 해당 시점의 사건 이후의 사건들은 모두 사라지게 된다. reset이란 뜻과 일맥 상통하다. 

협업 시 다른 cloned repo에 존재하던 commit log로 인해 파일이 살아나거나, 과거 이 력이 깔끔히 사라져 commit log tracking이 힘들어짐

```bash
git reset <옵션> <돌아가고싶은 커밋id>

ex)
git reset --soft abcdef
git reset --mixed abcdef  (옵션 작성안할 시 기본값)
git reset --hard abcdef 
git reset HEAD~10 (현재부터 10개 이전으로 복원)
```

`soft`: index 보존(add한 상태, staged 상태), 워킹 디렉터리의 파일 보존. 즉 모두 보존.–- `mixed`: index 취소(add하기 전 상태, unstaged 상태), 워킹 디렉터리의 파일 보존 (기본 옵션)–`hard`: index 취소(add하기 전 상태, unstaged 상태), 워킹 디렉터리의 파일 삭제. 즉 모두 취소.

`hard`는 가장 깔끔하지만 해당 커밋 이후의 작업들이 모두 사라지므로 확실할때만 신중히 사용해야겠습니다.

`mixed`의 경우 soft와 달리 워킹 디렉토리는 유지되지만 index가 취소되므로 취소된 파일들을 다시 add 해줘야합니다.

### Revert

특정 사건을 골라서 없던 일로 만들 기 때문에 과거 특정 사건을 없애주지만 revert를 했다는 이력이 남게된다. 그리고 없애려는 특정 사건의 과거와 미래가 얽혀서 충돌이 나는 경우가 있다. 

잘못하기 전 과거로 돌아가 최신을 유지하면서 되돌렸다는 이력을 commit으로 남겨 모 든 팀원이 이 사항을 공유하고 주지시킬 수 있음

```bash
$ git revert --no-commit HEAD~3.. 
$ git commit
$ git push origin <branch>
```

- 워킹 디렉토리에서 작업하다가 취소하고 싶을 때

```bash
//README 이름을 unread
mv README.md unread.md
```

### rebase

[[쉬운 Git] git rebase 의 방법과 다양한 문제 해결](https://asbear.tistory.com/188)

rebase를 사용하는 이유는 내가 브랜치에서 작업을 하고 있는 동안에 master에 적용된 커밋들을 나의 브랜치에 적용하기 위해서이다.

```bash
1) git add .
2) git commit -m "커밋 메시지 입력"
3) git rebase -i main
4) 리베이스 후 conflict 있으면 수정 진행 / 없으면 다음단계 진행
5) git add .
6) git rebase --continue
7) git push origin feature/브랜치이름 --force
```

## 모던 자바스크립트 
### 프로토타입
## 19.1 객체 지향 프로그래밍

**추상화**는 여러 속성들 중에서 프로그래밍에 필요한 속성만 간추려 내어 표현하는 것

**객체**는 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조 

**객체지향 프로그래밍**은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임.

- 객체의 **상태**를 나타내는 데이터(**프로퍼티**)와 상태 데이터를 조작할 수 있는 **동작(메서드)**
- 객체는 독립적인 부품이 될 수 있지만 다른 객체와 관계성을 가질 수 있다

## 19.2 상속과 프로토타입

**상속**

- 객체 지향 프로그래밍의 핵심
- 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 의미
- 자바스크립트는 프로토타입을 기반으로 상속을 구현함
- 불필요한 중복을 제거 ⇒ 기존 코드 적극적으로 재사용하기 (비용줄이기 가능)

**내용이 동일한 메서드의 중복 생성**

- 메모리 낭비
- 퍼포먼스에 악영향

⇒ 그렇다면 중복을 프로토타입 기반의 상속으로 없애보자!

```jsx
function Person(name){
  this.name = 'Lee',
	this.sayHi = function(){
    console.log('Hi! my name is ' + this.name);
  }
};

//sayHi 메서드를 중복 생성하는 단점이 생김. 모든 인스턴스가 중복해서 소유하게 됨
// 따라서 메서드는 하나만 생성해서 모든 인스턴스가 공유하는게 바람직
```

```jsx
function Person(name){
  this.name = 'Lee',
};

//가독성이 안좋고, 캡슐화가 진행되지 않음 
// 메서드를 공유해서 사용할 수 있도록 프로토타입에 추가함
//프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩됨
//sayHi는 Person의 메서드로 할당됨
Person.prototype.sayHi = function(){
    console.log('Hi! my name is ' + this.name);
  }

console.dir(person);

//생성자 함수에서 만든 인스턴스는 자신의 프로토타입 즉, 상위(부모)
// 객체 역할을 하는 Circle.prototype의 모든 **프로퍼티와 메서드**를 상속받는다.
```

생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메서드를 미리 구현해두면, 생성자 함수가 생성할 인스턴스 들은 별도 구현 없이도 상위(부모) 객체인 프로토타입의 자산을 공유해 사용할 수 있다!

## 19.3 프로토타입 객체

**프로토타입 객체**는 **객체 간 상속**을 구현하기 위해 사용

**프로토 타입**은 어떤 객체의 상위(부모) 객체의 역할을 하는 객체로 다른 객체에 공유 프로퍼티( 메서드 포함)을 제공함 → 상속 받으면 자유롭게 사용 가능 

> **프로토타입**은 다른 객체에 공유 프로퍼티(메서드 포함)를 제공하는 객체
> 

`[[prototype]]` 

- 모든 객체가 내부 슬롯으로 가짐
- 내부 슬롯의 값은 프로토타입의 참조다
- 프로토타입은 **객체 생성 방식**에 의해 결정되고  `[[prototype]]`에 저장됨

모든 객체는 하나의 프로토타입을 갖는다. 

모든 프로토타입은 **생성자 함수**와 연결됨

프로토타입은 자신의 constructor 프로퍼티를 통해 생성자 함수에 접근 가능 

생성자 함수는 자신의 prototype 프로퍼티를 통해 프로토타입에 접근 가능

> 왜 내부 슬롯에 직접 접근이 불가능할까?

이는 프로토타입 체인의 단방향을 지키기 위해서다. 만약 직접 접근가능하다면 서로가 서로의 프로토타입이 되면서 프로토타입 체인이 무한대로 돌게된다.
> 
> 
> ```jsx
> const a = {}
> const b = {}
> 
> a.__proto__ = b
> b.__proto__ = a // Uncaught TypeError: Cyclic __proto__ value
> ```
> 

### 19.3.1 __**proto**__ 접근자 프로퍼티

모든 객체는 `__proto__` 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 `[[prototype]]` 내부 슬롯에 간접적으로 접근할 수 있음
